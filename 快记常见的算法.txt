排序算法
-----------------
冒泡排序   不断地从前往后交换位置，进行n轮，从右边开始逐渐确定顺序
选择排序   不断地从前往后确定最小数的索引，进行n轮，从左边开始确定顺序
插入排序   不断地从前往后移动当前值的索引，将当前值以前的的比他大的都后移，插入当前值，直到遍历到到最后,从左边开始确定顺序
归并排序   递归，将数组不断地对半分，直到只有一个或者两个，然后返回接受两个数组为参数并返回一个排好序的数组的合并函数的结果，合并函数可以分开写
快速排序   递归，随便比如取第一个数为当前值，比他大的放他的左边，比他小的放他的右边，返回递归调用拼接

搜索算法
-----------------
顺序搜索    从左往右顺序搜索
二分搜索    可以用双指针，从两边开始，不断往中间移动，遍历比递归方便点  只能针对排好序的，排序前的搞不了
内插搜索    其实就是确定中间指针的时候用的是当前值处于区间大小的值作为索引，一遍快速找到这个值

-----------------
随机算法
分而治之
动态规划
贪心算法

还差的代码：
计数排序     所有的值中找最大的值，然后建立一个长度比这个数值大一全为0的数组a，然后遍历查找的数组，比如找到b,就将a中索引为b的值加一，最后的最后，将这个数组a中值不为0的索引按值double几个，拼接起来就是排好序的数组了
基数排序   比如基数设为十，十进制嘛，从低位开始，将数组中的数字依次插入十个桶中（其实就是二维数组），然后十个桶拼接起来，循环进行，直到最大的数已经小于当前基数
桶排序    分布式排序方法 先按规则分到桶里，然后用在桶里用某个算法，比如快排也行的排序，然后拼接桶就是了
随机算法  生产随机数的
动态规划，dp   两个条件，从基数条件不断往外加新条件的过程中，结果取 如果不加新条件的上一的最好的结果 与 加了新条件之后，扣掉为了加新条件付出的代价之后，上一次的最好的结果  的最大值  作为最优解，然后不断进行  直到没有新条件，至于新条件添加的顺序，自己自行决定   有个二维表的挺好写，不用填满表   -------------（欠一个0-1背包，还有最长公共子序列）
贪心算法  算出每个新条件的价值，然后将原本的条件中价值最低的那个条件与它比较，如果小了，就取新条件，丢掉最低的那个条件
dfs bfs